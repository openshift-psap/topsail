import os
import json
import urllib.request
import urllib.error
import ssl
from typing import Optional
import logging

def get_kubernetes_node_name() -> Optional[str]:
    # generated by Gemini
    """
    Retrieves the Kubernetes node name for the current running pod by
    communicating with the Kubernetes API server using the pod's service account.

    This function mimics the shell logic:
    1. Read POD_NAME, NAMESPACE, and TOKEN from files/environment.
    2. Construct the APISERVER URL.
    3. Make a secure API call to fetch the pod object.
    4. Extract the '.spec.nodeName' field.

    Returns:
        The name of the node the pod is scheduled on, or None if the retrieval fails.
    """
    SA_PATH = "/var/run/secrets/kubernetes.io/serviceaccount"
    CA_CERT_PATH = os.path.join(SA_PATH, "ca.crt")

    # --- 1. Define Variables ---

    # 1.1 POD_NAME (Hostname)
    try:
        with open("/proc/sys/kernel/hostname", "r") as f:
            POD_NAME = f.read().strip()
    except OSError:
        # Fallback to os.uname().nodename, which is often the same
        POD_NAME = os.uname().nodename

    # 1.2 NAMESPACE
    try:
        with open(os.path.join(SA_PATH, "namespace"), "r") as f:
            NAMESPACE = f.read().strip()
    except FileNotFoundError:
        logging.error("Namespace file not found. Running outside a standard K8s Pod?")
        return None

    # 1.3 TOKEN
    try:
        with open(os.path.join(SA_PATH, "token"), "r") as f:
            TOKEN = f.read().strip()
    except FileNotFoundError:
        logging.error("Service account token not found.")
        return None

    # 1.4 APISERVER URL
    K8S_HOST = os.environ.get("KUBERNETES_SERVICE_HOST")
    K8S_PORT = os.environ.get("KUBERNETES_SERVICE_PORT")

    if not (K8S_HOST and K8S_PORT):
        logging.error("KUBERNETES_SERVICE_HOST or PORT environment variables not set.")
        return None

    APISERVER = f"https://{K8S_HOST}:{K8S_PORT}"

    # --- 2. Make the API Call ---

    URL = f"{APISERVER}/api/v1/namespaces/{NAMESPACE}/pods/{POD_NAME}"

    try:
        # Create SSL context with CA certificate
        ssl_context = ssl.create_default_context(cafile=CA_CERT_PATH)

        # Create request with authorization header
        request = urllib.request.Request(URL)
        request.add_header("Authorization", f"Bearer {TOKEN}")

        # Make the API call with SSL verification and timeout
        with urllib.request.urlopen(request, timeout=5, context=ssl_context) as response:
            response_data = response.read()
            pod_data = json.loads(response_data.decode('utf-8'))

        # Safely extract the nodeName field
        node_name = pod_data.get('spec', {}).get('nodeName')

        if node_name:
            return node_name
        else:
            logging.warning("'nodeName' field not found in the pod specification.")
            return None

    except urllib.error.HTTPError as e:
        logging.error(f"Failed to query Kubernetes API at {URL}. HTTP Error {e.code}: {e.reason}")
        return None
    except urllib.error.URLError as e:
        logging.error(f"Failed to query Kubernetes API at {URL}. URL Error: {e.reason}")
        return None
    except json.JSONDecodeError:
        logging.error("Failed to parse API response as JSON.")
        return None
    except OSError as e:
        logging.error(f"Failed to read CA certificate or network error: {e}")
        return None


# --- Example Usage ---
if __name__ == '__main__':
    # This block will only run if you execute the script directly

    # NOTE: This uses Python's built-in urllib library (no external dependencies)

    logging.info("Attempting to determine Kubernetes Node Name...")

    NODE_NAME = get_kubernetes_node_name()

    if NODE_NAME:
        logging.info(f"\n✅ Pod is running on Node: **{NODE_NAME}**")
    else:
        logging.info("\n❌ Could not determine Node Name (Check if you are running inside a properly configured K8s Pod).")
